

转自：http://xuguangzhi2003.blog.163.com/blog/static/134908721201011228733362/

一段synchronized的代码被一个线程执行之前，他要先拿到执行这段代码的权限，在 java里边就是拿到某个同步对象的锁（一个对象只有一把锁）； 如果这个时候同步对象的锁被其他线程拿走了，他（这个线程）就只能等了（线程阻塞在锁池 等待队列中）。 取到锁后，他就开始执行同步代码(被synchronized修饰的代码）；线程执行完同步代码后马上就把锁还给同步对象，其他在锁池中 等待的某个线程就可以拿到锁执行同步代码了。这样就保证了同步代码在统一时刻只有一个线程在执行。

众所周知，在Java多线程编程中，一个非常重要的方面就是线程的同步问题。
关于线程的同步，一般有以下解决方法：

1. 在需要同步的方法的方法签名中加入synchronized关键字。

2. 使用synchronized块对需要进行同步的代码段进行同步。

3. 使用JDK 5中提供的java.util.concurrent.lock包中的Lock对象。

另外，为了解决多个线程对同一变量进行访问时可能发生的安全性问题，我们不仅可以采用同步机制，更可以通过JDK 1.2中加入的ThreadLocal来保证更好的并发性。

本篇中，将详细的讨论Java多线程同步机制，并对ThreadLocal做出探讨。

大致的目录结构如下：

一、线程的先来后到——问题的提出：为什么要有多线程同步？Java多线程同步的机制是什么？
二、给我一把锁，我能创造一个规矩——传统的多线程同步编程方法有哪些？他们有何异同？
三、Lock来了，大家都让开—— Java并发框架中的Lock详解。
四、你有我有全都有—— ThreadLocal如何解决并发安全性？
五、总结——Java线程安全的几种方法对比。


一、线程的先来后到

我 们来举一个Dirty的例子：某餐厅的卫生间很小，几乎只能容纳一个人如厕。为了保证不受干扰，如厕的人进入卫生间，就要锁上房门。我们可以把卫生间想 象成是共享的资源，而众多需要如厕的人可以被视作多个线程。假如卫生间当前有人占用，那么其他人必须等待，直到这个人如厕完毕，打开房门走出来为止。这就 好比多个线程共享一个资源的时候，是一定要分出先来后到的。

有人说：那如果我没有这道门会怎样呢？让两个线程相互竞争，谁抢先了，谁就 可以先干活，这样多好阿？但是我们知道：如果厕所没有门的话，如厕的人一起涌向 厕所，那么必然会发生争执，正常的如厕步骤就会被打乱，很有可能会发生意想不到的结果，例如某些人可能只好被迫在不正确的地方施肥……

正是因为有这道门，任何一个单独进入如厕的人都可以顺利的完成他们的如厕过程，而不会被干扰，甚至发生以外的结果。这就是说，如厕的时候要讲究先来后到。


那 么在Java 多线程程序当中，当多个线程竞争同一个资源的时候，如何能够保证他们不会产生“打架”的情况呢？有人说是使用同步机制。没错，像上面这个例子，就是典型的 同步案例，一旦第一位开始如厕，则第二位必须等待第一位结束，才能开始他的如厕过程。一个线程，一旦进入某一过程，必须等待正常的返回，并退出这一过程， 下一个线程才能开始这个过程。这里，最关键的就是卫生间的门。其实，卫生间的门担任的是资源锁的角色，只要如厕的人锁上门，就相当于获得了这个锁，而当他 打开锁出来以后，就相当于释放了这个锁。

也就是说，多线程的线程同步机制实际上是靠锁的概念来控制的。那么在Java程序当中，锁是如何体现的呢？


让我们从JVM的角度来看看锁这个概念：

在Java程序运行时环境中，JVM需要对两类线程共享的数据进行协调：
1）保存在堆中的实例变量
2）保存在方法区中的类变量

这两类数据是被所有线程共享的。
（程序不需要协调保存在Java 栈当中的数据。因为这些数据是属于拥有该栈的线程所私有的。）

在java虚拟机中，每个对象和类在逻辑上都是和一个监视器相关联的。
对于对象来说，相关联的监视器保护对象的实例变量。

对于类来说，监视器保护类的类变量。

（如果一个对象没有实例变量，或者一个类没有变量，相关联的监视器就什么也不监视。）
为了实现监视器的排他性监视能力，java虚拟机为每一个对象和类都关联一个锁。代表任何时候只允许一个线程拥有的特权。线程访问实例变量或者类变量不需锁。

但是如果线程获取了锁，那么在它释放这个锁之前，就没有其他线程可以获取同样数据的锁了。（锁住一个对象就是获取对象相关联的监视器）

类锁实际上用对象锁来实现。当虚拟机装载一个class文件的时候，它就会创建一个java.lang.Class类的实例。当锁住一个对象的时候，实际上锁住的是那个类的Class对象。

一个线程可以多次对同一个对象上锁。对于每一个对象，java虚拟机维护一个加锁计数器，线程每获得一次该对象，计数器就加1，每释放一次，计数器就减 1，当计数器值为0时，锁就被完全释放了。

java编程人员不需要自己动手加锁，对象锁是java虚拟机内部使用的。

在java程序中，只需要使用synchronized块或者synchronized方法就可以标志一个监视区域。当每次进入一个监视区域时，java 虚拟机都会自动锁上对象或者类。

看到这里，我想你们一定都疲劳了吧？o(∩_∩)o...哈哈。让我们休息一下，但是在这之前，请你们一定要记着：
当一个有限的资源被多个线程共享的时候，为了保证对共享资源的互斥访问，我们一定要给他们排出一个先来后到。而要做到这一点，对象锁在这里起着非常重要的作用。

在上一篇中，我们讲到了多线程是如何处理共享资源的，以及保证他们对资源进行互斥访问所依赖的重要机制：对象锁。



本篇中，我们来看一看传统的同步实现方式以及这背后的原理。



很多人都知道，在Java多线程编程中，有一个重要的关键字，synchronized。但是很多人看到这个东西会感到困惑：“都说同步机制是通过对象锁来实现的，但是这么一个关键字，我也看不出来Java程序锁住了哪个对象阿？“


没错，我一开始也是对这个问题感到困惑和不解。不过还好，我们有下面的这个例程：
Java代码  收藏代码

    public class ThreadTest extends Thread {     
         private int threadNo;     
         public ThreadTest(int threadNo) {     
             this.threadNo = threadNo;     
         }     
         public static void main(String[] args) throws Exception {     
             for (int i = 1; i < 10; i++) {     
                new ThreadTest(i).start();     
                 Thread.sleep(1);     
             }     
          }     
           
         @Override    
          public synchronized void run() {     
             for (int i = 1; i < 10000; i++) {     
                 System.out.println("No." + threadNo + ":" + i);     
             }     
          }     
      }  

 

  

      这个程序其实就是让10个线程在控制台上数数，从1数到9999。理想情况下，我们希望看到一个线程数完，然后才是另一个线程开始数数。但是这个程序的执行过程告诉我们，这些线程还是乱糟糟的在那里抢着报数，丝毫没有任何规矩可言。
     但是细心的读者注意到：run方法还是加了一个synchronized关键字的，按道理说，这些线程应该可以一个接一个的执行这个run方法才对阿。
     但是通过上一篇中，我们提到的，对于一个成员方法加synchronized关键字，这实际上是以这个成员方法所在的对象本身作为对象锁。在本例中，就是 以ThreadTest类的一个具体对象，也就是该线程自身作为对象锁的。一共十个线程，每个线程持有自己 线程对象的那个对象锁。这必然不能产生同步的效果。换句话说，如果要对这些线程进行同步，那么这些线程所持有的对象锁应当是共享且唯一的！

我们来看下面的例程：

Java代码  收藏代码

     public class ThreadTest2 extends Thread {     
      private int threadNo; private String lock;     
      public ThreadTest2(int threadNo, String lock) {     
      this.threadNo = threadNo;     
          this.lock = lock;   }     
     public static void main(String[] args) throws Exception {     
        String lock = new String("lock");     
          for (int i = 1; i < 10; i++) {       
       new ThreadTest2(i, lock).start();     
          Thread.sleep(1);     
         }     
      }       
    public void run() {       
     synchronized (lock) {     
          for (int i = 1; i < 10000; i++) {     
           System.out.println("No." + threadNo + ":" + i);     
        }        
     }       
     }     
     }    

 

        我们注意到，该程序通过在main方法启动10个线程之前，创建了一个String类型的对象。并通过ThreadTest2的构造函数，将这个对象赋值 给每一个ThreadTest2线程对象中的私有变量lock。根据Java方法的传值特点，我们知道，这些线程的lock变量实际上指向的是堆内存中的 同一个区域，即存放main函数中的lock变量的区域。
        程序将原来run方法前的synchronized关键字去掉，换用了run方法中的一个synchronized块来实现。这个同步块的对象锁，就是 main方法中创建的那个String对象。换句话说，他们指向的是同一个String类型的对象，对象锁是共享且唯一的！

于是，我们看到了预期的效果：10个线程不再是争先恐后的报数了，而是一个接一个的报数。

再来看下面的例程：

Java代码  收藏代码

    public class ThreadTest3 extends Thread {     
         
        private int threadNo;     
        private String lock;     
         
        public ThreadTest3(int threadNo) {     
            this.threadNo = threadNo;     
        }     
         
        public static void main(String[] args) throws Exception {     
             
            for (int i = 1; i < 20; i++) {     
                new ThreadTest3(i).start();     
                Thread.sleep(1);     
            }     
        }     
         
        public static synchronized void abc(int threadNo) {     
            for (int i = 1; i < 10000; i++) {     
                    
                    System.out.println("No." + threadNo + ":" + i);             
            }     
        }     
         
        public void run() {     
            abc(threadNo);     
        }     
    }  

 

 
  

细心的读者发现了：这段代码没有使用main方法中创建的String对象作为这10个线程的线程锁。而是通过在run方法中调用本线 程中一个静态的同步 方法abc而实现了线程的同步。我想看到这里，你们应该很困惑：这里synchronized静态方法是用什么来做对象锁的呢？



我们知道，对于同步静态方法，对象锁就是该静态放发所在的类的Class实例，由于在JVM中，所有被加载的类都有唯一的类对象，具体到本例，就是唯一的 ThreadTest3.class对象。不管我们创建了该类的多少实例，但是它的类实例仍然是一个！



这样我们就知道了：

1、对于同步的方法或者代码块来说，必须获得对象锁才能够进入同步方法或者代码块进行操作；


2、如果采用method级别的同步，则对象锁即为method所在的对象，如果是静态方法，对象锁即指method所在的
Class对象(唯一)；


3、对于代码块，对象锁即指synchronized(abc)中的abc；


4、因为第一种情况，对象锁即为每一个线程对象，因此有多个，所以同步失效，第二种共用同一个对象锁lock，因此同步生效，第三个因为是
static因此对象锁为ThreadTest3的class 对象，因此同步生效。

如上述正确，则同步有两种方式，同步块和同步方法（为什么没有wait和notify？这个我会在补充章节中做出阐述）

如果是同步代码块，则对象锁需要编程人员自己指定，一般有些代码为synchronized(this)只有在单态模式才生效；
（本类的实例有且只有一个）

如果是同步方法，则分静态和非静态两种 。

静态方法则一定会同步，非静态方法需在单例模式才生效，推荐用静态方法(不用担心是否单例)。

所以说，在Java多线程编程中，最常见的synchronized关键字实际上是依靠对象锁的机制来实现线程同步的。
我们似乎可以听到synchronized在向我们说：“给我一把 锁，我能创造一个规矩”。
